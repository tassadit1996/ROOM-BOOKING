{"ast":null,"code":"export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? \"Choose date, selected date is \".concat(utils.format(utils.date(rawValue), 'fullDate')) : 'Choose date';\n}\nexport var getDisplayDate = function getDisplayDate(utils, value, inputFormat) {\n  var date = utils.date(value);\n  var isEmpty = value === null;\n  if (isEmpty) {\n    return '';\n  }\n  return utils.isValid(date) ? utils.formatByString(\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nexport function pick12hOr24hFormat(userFormat, ampm, formats) {\n  if (userFormat) {\n    return userFormat;\n  }\n  if (typeof ampm === 'undefined') {\n    return formats.localized;\n  }\n  return ampm ? formats['12h'] : formats['24h'];\n}\nvar MASK_USER_INPUT_SYMBOL = '_';\nvar staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nvar staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  var formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  var inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  var inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  var isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    console.warn(\"The mask \\\"\".concat(mask, \"\\\" you passed is not valid for the format used \").concat(format, \". Falling down to uncontrolled not-masked input.\"));\n  }\n  return isMaskValid;\n}\nexport var maskedDateFormatter = function maskedDateFormatter(mask, acceptRegexp) {\n  return function (value) {\n    return value.split('').map(function (char, i) {\n      acceptRegexp.lastIndex = 0;\n      if (i > mask.length - 1) {\n        return '';\n      }\n      var maskChar = mask[i];\n      var nextMaskChar = mask[i + 1];\n      var acceptedChar = acceptRegexp.test(char) ? char : '';\n      var formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n      if (i === value.length - 1 && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n        // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n        return formattedChar ? formattedChar + nextMaskChar : '';\n      }\n      return formattedChar;\n    }).join('');\n  };\n};","map":{"version":3,"names":["getTextFieldAriaText","rawValue","utils","isValid","date","format","getDisplayDate","value","inputFormat","isEmpty","formatByString","pick12hOr24hFormat","userFormat","ampm","formats","localized","MASK_USER_INPUT_SYMBOL","staticDateWith2DigitTokens","staticDateWith1DigitTokens","checkMaskIsValidForCurrentFormat","mask","acceptRegex","formattedDateWith1Digit","inferredFormatPatternWith1Digits","replace","inferredFormatPatternWith2Digits","isMaskValid","lib","process","env","NODE_ENV","console","warn","maskedDateFormatter","acceptRegexp","split","map","char","i","lastIndex","length","maskChar","nextMaskChar","acceptedChar","test","formattedChar","join"],"sources":["C:/Users/adoud/Desktop/hotel_mern/client/node_modules/@material-ui/lab/internal/pickers/text-field-helper.js"],"sourcesContent":["export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? `Choose date, selected date is ${utils.format(utils.date(rawValue), 'fullDate')}` : 'Choose date';\n}\nexport const getDisplayDate = (utils, value, inputFormat) => {\n  const date = utils.date(value);\n  const isEmpty = value === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nexport function pick12hOr24hFormat(userFormat, ampm, formats) {\n  if (userFormat) {\n    return userFormat;\n  }\n\n  if (typeof ampm === 'undefined') {\n    return formats.localized;\n  }\n\n  return ampm ? formats['12h'] : formats['24h'];\n}\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    console.warn(`The mask \"${mask}\" you passed is not valid for the format used ${format}. Falling down to uncontrolled not-masked input.`);\n  }\n\n  return isMaskValid;\n}\nexport const maskedDateFormatter = (mask, acceptRegexp) => value => {\n  return value.split('').map((char, i) => {\n    acceptRegexp.lastIndex = 0;\n\n    if (i > mask.length - 1) {\n      return '';\n    }\n\n    const maskChar = mask[i];\n    const nextMaskChar = mask[i + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n\n    if (i === value.length - 1 && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n\n    return formattedChar;\n  }).join('');\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}